Specification
------------------
EllipsoidSpec.hs:
KNNSpec.hs:
Label.hs:
Learner.hs:
Loss.hs:
OnlineLearner.hs:
Project Speficiation: this file.
VectorUtils.hs:
Writer.hs:

lazy evaluation - To be checked
Pattern matching - Multiple functions, Learner.hs error i.e
higher order functions - Multiple functions, Learner.hs error i.e
new types - Multiple places, KNNKnowledge in OnlineLearner.hs i.e
derived - Multiple places, Label derived Show in Label.hs (also instance of Ord and Eq)
lambda functions - Where DiffList instantiate Monoid at Writer.hs.
applicative functor - Writer.hs Monad in Writer.hs (instance of applicative as it is a monad).
monoids - DiffList in Writer.hs instantiate Monoid.

Functionality Pros
------------------
1) High order functions make the ability to get functions that get as many
parameters as needed and returns function without complicated function pointers.

2) It was easy to write the tests because each function can be isolated
as it has its specific arguments and return value without any relation to a
class or globals.

3) It was easier to debug as the functions are stateless and
no members or in function variables could be a reason for bugs.


Functionality Cons
------------------
1) Its hard to predict the spaced used in the program (Due to lazyness 4 can actually be 2+2 which take more bits to represent).
2) Its hard to compare the running time in relation to a given imperative code(Most of existing code is written by imperative languages).
3) As imperative programmers its hard to learn and master(Due to the differences between the methodology).


Remaining Tasks(Temp)
------------------
Add error to OnlineLearner
Refactor Learner?
Finish Project Specification
