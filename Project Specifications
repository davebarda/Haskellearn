Specification
------------------

Files
------------------
EllipsoidSpec.hs
KNNSpec.hs
Label.hs
Learner.hs
Loss.hs
OnlineLearner.hs
Project Speficiation
VectorUtils.hs
Writer.hs

Idioms we used
------------------
Pattern matching - classify in Learner.hs, Eq in Label.hs, etc'.
Higher order functions - error in Learner.hs, doing `mappend` between DiffLists
  creates a new function in the DiffList (there is a concatenation of functions), etc'.
New types - LearningParameters, TrainingKnowledge in Learner.hs, etc'.
Derived - Label derived Show in Label.hs (also instance of Ord and Eq).
Lambda functions - We use lambdas where DiffList instantiate Monoid at Writer.hs (line 37).
Applicative functor - Writer monad in Writer.hs (instance of applicative as it is a monad).
Monoids - DiffList in Writer.hs instantiate Monoid.
Lazy evaluation - takeFromDiffList in DiffList, Printing a DiffList is lazy, etc'.

Functionality Pros
------------------
1) Writing functional code is like writing math!

2) High order functions make the ability to get functions that get as many
parameters as needed and returns function without complicated function pointers.

3) It was easy to write the tests because each function can be isolated
as it has its specific arguments and return value without any relation to a
class or global variables.

4) It was easier to debug as the functions are stateless and
no members or in function variables could be a reason for bugs.

5) Code usually is much shorter.


Functionality Cons
------------------
1) Its hard to predict the spaced used in the program (Due to lazyness 4 can
actually be 2+2 which take more bits to represent).

2) Its hard to compare the running time in relation to a given imperative code
(most of the existing code is written by imperative languages).

3) As imperative programmers its hard to learn and master (due to the differences
between imperative and functional languages).
